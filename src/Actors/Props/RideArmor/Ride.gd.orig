extends NewAbility

onready var ceiling_check: RayCast2D = $ceiling_check
onready var ceiling_check_2: RayCast2D = $ceiling_check2
onready var animation: AnimationController = AnimationController.new($"../animatedSprite", self)

var destroy_damage: = 8
var rider
var recent_rider
var player_nearby: bool = false

signal rider_on
signal rider_off


func should_execute() -> bool:
	if ceiling_check.is_colliding():
		return false
	return character.active and character.has_health() and current_conflicts.size() == 0

func _Setup() -> void :
	make_rider()
	emit_signal("rider_on")

func _Update(_delta: float) -> void :
	if not rider.has_health():
		character.emit_signal("death")

func _Interrupt() -> void :
	eject()
	emit_signal("rider_off")

func is_body_transformed(body) -> bool:
	var _body_parent = body.get_parent()
	if _body_parent != null:
		if _body_parent.name == "Axl":
			var _transform_node = _body_parent.get_node("Shot/Transform")
			if _transform_node != null:
				if _transform_node.transformed:
					return true
			var _special_node = _body_parent.get_node("Special")
			if _special_node != null:
				if _special_node.is_executing_special:
					return true
		if _body_parent.name == "X":
			var _gigacrash_node = _body_parent.get_node("Shot/GigaCrash")
			if _gigacrash_node != null:
				if _gigacrash_node.is_executing_special:
					return true
	return false

func _on_body_enter(body) -> void :
	if should_execute() and is_rideable(body) and not is_body_transformed(body):
<<<<<<< HEAD
=======
		var character = body.get_character()
		if character == GameManager.inactive_player:
			return
>>>>>>> source_private/main
		rider = body.get_character()
		recent_rider = body.get_character()
		_on_signal()

func reenable_ride_time() -> void :
	recent_rider = null

func is_rideable(player) -> bool:
	var non_states: = ["Ride", "Forced", "Finish", "Intro"]
	if GameManager.player:
		if not GameManager.player.listening_to_inputs:
			return false
	if player.has_method("get_character"):
		var character = player.get_character()
		if character.has_method("is_executing_either"):
			if not character.is_executing_either(non_states):
				return recent_rider == null
	return false

func make_rider() -> void :
	parent_rider_to_self(rider)
	
	rider.get_node("animatedSprite").visible = false
	rider.emit_signal("land")
	rider.ride(character)
	rider.disable_collision()
	Event.emit_signal("ridearmor_activate")
	Log("Controlled by " + rider.name)

func parent_rider_to_self(_rider):
	_rider.get_parent().remove_child(_rider)
	get_parent().call_deferred("add_child", _rider)

func eject():
	remove_rider()
	rider = null

func force_eject():
	Log("Explosion force ejected rider.")
	remove_rider()
	if is_instance_valid(rider):
		rider.damage(destroy_damage, rider)
	rider = null

func remove_rider():
	if is_instance_valid(rider):
		Log("Ejecting: " + rider.name)
		return_rider_to_original_parent()
		rider.enable_collision()
		rider.eject(character)
		rider.get_node("animatedSprite").modulate = Color(1, 1, 1, 1)
		Event.emit_signal("ridearmor_deactivate")
		Tools.timer(0.65, "reenable_ride_time", self)

func return_rider_to_original_parent():
	get_parent().remove_child(rider)
	get_parent().get_parent().add_child(rider)
	rider.global_position = global_position
	rider.global_position.y = global_position.y + 12


func _on_new_direction(dir) -> void :
	scale.x = dir

